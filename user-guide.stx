title: Weblocks User Guide
author: Leslie P. Polzer
date: 27. May 2009
language: english

w_begdiv(metas)
dnl <link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="pygments-style.css"/>
<link rel="stylesheet" type="text/css" href="weblocks.css"/>
w_enddiv(metas)

dnl define(`ww_symbol',`w_literal(translit($1,`a-z',`A-Z'))')
define(`ww_symbol',`w_emph(translit($1,`A-Z',`a-z'))')

This is the user's guide to Weblocks.

http://teddyb.org/rlp/tiki-index.php?page!Learning+About+Weblocks

! Introduction

!! Getting Support

There is both excellent community and professional support available for Weblocks.

Community support is available via the Google group at
w_url(`http://groups.google.com/group/weblocks').

For commercial support and consulting contact Leslie P. Polzer
`<'w_link(`mailto:polzer@gnu.org',`w_literal(`polzer@gnu.org')')`>'.


!! Installation

!!! Setup your Common Lisp environment

You can skip this section if you already have a comfortable Common Lisp environment.


!!!! Common Lisp implementation

First you must choose a Common Lisp implementation.

Weblocks is designed and implemented to be portable and should run on the most popular
Common Lisp implementations. It is currently tested best on SBCL and Clozure CL, though.


!!!! Development environment setup

There are at least two fundamentally different development approaches for using
Common Lisp:

  # Editor-centric development: you access all Lisp functions from within your editor.

    Example: Emacs/Slime, Vim/Limp, Lispworks/IDE.
    
    Incremental development happens mainly on the S-Expression level. This means that you
    edit a SEXP and send it with the help of editor directly to your Lisp image, which
    evaluates it, thus affecting the current Lisp environment.

  # UNIX-style development: one tool for each job. The editor is not all that important
    here (as long as you're comfortable with it and it supports at least a basic level
    of paren highlighting.
    
    Example: Vim and your favorite terminal emulator. You start Vim in one window and
    your Lisp in another. Interaction happens by reloading your applications ASDF system
    and simple copy/paste of snippets.

We will try to be largely agnostic of the development approach in this manual which actually
means that we tend towards the second approach: Lisp calls are referred to by what you'd
type in your REPL, not by Emacs shortcut as it is often the case.

For a basic comfortable SBCL setup, see w_refer(appA,`Appendix A').
 

!!!! Installation

There is a comprehensive installation guide on the main web site:

  http://weblocks.viridian-project.de/installation


!! Setting up a project

Weblocks comes with a simple application template generator.

Start your Lisp and run

CODE_BEGIN lisp
(wop:make-app 'NAME "DIR")
CODE_END

This will initialize a barebones application called NAME in directory
DIR.

Another effective way to hack on a new application is copying
the code of an application from the w_literal(examples/) directory.


!! Components of Weblocks

!!! Widgets

Widgets are the main building blocks of Weblocks (hence the name).

At the heart of Weblocks is a tree`'w_footnote(An acyclic graph with exactly one
parent per node) of widgets that is manipulated by the clients requests. When a
client sends its first request to a Weblocks application then a new session is
started for it and a widget tree is associated with this session.

This initial widget tree is computed as defined by the application developer.
A special function (usually called ww_symbol(init-user-session)) is called by Weblocks
to initialize a new session. This function then proceeds to set up a
widget tree by adding children to the root of the widget tree
(accessible with the macro ww_symbol(root-widget)).

The initial content and structure of the widget tree may depend on arbitrary
factors; it is conceivable (although probably not very sensible) to generate
different widget trees depending on the time of day.

A client's request for a specific URI modifies the widget tree: widgets
called /dispatchers/ choose their one child based on the current request
URI.

There is a convenience function ww_symbol(MAKE-WIDGET) that creates widgets
from strings (anything that can be printed, in fact) and functions.


!!! Actions

Apart from session initialization the widget tree may be modified by /actions/.

Actions are plain functions that are stored in a session hash table the keys
of which are unique identifiers. This way they can be called by the browser.

When Javascript is available actions will be called via AJAX, otherwise
a normal request will be initiated.

It is often useful to set up closures as actions.

Example of typical action usage:

CODE_BEGIN lisp
(defwidget counter ()
  ((count :accessor count-of :initform 0)))

(defmethod render-widget-body ((widget my-widget) &rest args)
  (with-html
    (:p (esc (format nil "The counter is at ~D." (count-of widget))))
    (:p (render-link
         (lambda (&rest args)
          ;; closes over WIDGET.
          (incf (count-of widget)))
         "Count up!"))))
CODE_END


!!! Navigations and dispatchers

Dispatchers are widget that configure themselves and their children
(i.e. broadly speaking the widget tree) based on the URI of the request.

Navigations are dispatchers that maintain a simple one-to-one association between
an URI token`'w_footnote(each path component of an URI is a token; for example
in `"/foo/bar/quux"' there are three tokens foo, bar and quux.) and
a widget.

Note that each widget can also in turn be a navigation that consumes an
URI token, thereby building a many-to-many relationship between tokens
and widgets.

The function ww_symbol(MAKE-NAVIGATION) is a convenience frontend for building
navigations.

The first argument is a title for the navigation. The rest of the arguments
map tokens to widgets:

CODE_BEGIN lisp
(defun init-user-session (root)
  (setf root (make-navigation "Food Shop"
                              "Fruits" (make-fruit-navigation)
                              "Vegetables" (make-vegetables-navigation)
                              "Billing" (make-instance 'billing-widget :shop-type 'food))))
CODE_END

ww_symbol(MAKE-WIDGET) is applied to the widget argument so you can use strings
and function designators`'w_footnote(i.e. symbols naming a global function
and function objects themselves) instead of widgets in this context.


!!! Views

Views provide convenient ways to define how data object are to
be rendered.

Weblocks currently comes with three types of views: data views, table views
and form views.

Form views are especially useful because they let you build forms
in a declarative manner, error checking and reporting included. 

Views mainly consist of a rendering framework unique to the
view`'w_footnote(The table view for example knows how to render a HTML table.)
and a series of view fields.

View fields usually map to the slots of your data class but they are
flexible enough to be used in any other way. Associated with each view field
irregardless of the view type are things like a human-readable label and
information on how to render the field (presentation).

Form views include additional parameters like how to translate user
input to a proper model value (parser) and constraints on the data
(satisfies).


!! Stores

Weblocks offers a storage framework with several backends. At the
moment the supported backends are Elephant, cl-prevalence, CLSQL
and in-memory storage.

You are free to use your own storage mechanisms, however.

w_refer(appC,`Appendix C') offers a comparison of the different stores.


!!! Applications

One Lisp image may serve multiple web applications at once.

The target web application of a request can be determined based
on the hostname, the port or the URI for example.

You don't have to worry much about this if you only intend to
run a single application.


!!! HTML and Javascript generation facilities and utilies

Weblocks comes with CL-WHO and Parenscript, two powerful packages
that provide Lisp compilers for HTML and Javascript.

This means no more munging around with strings, which in turn
means

  * no more annoying mistakes like forgetting a semicolon
    or forgetting to close a tag

  * no need to remember infix precedence rules 

  * make full use of Lisps selective quoting facilities

Javascript may still be written as simple strings however.
This comes in handy sometimes when working with a larger example
copied from a Javascript library manual.

And you're free to use other facilities as you prefer.
For example YACLML`'w_footnote(`Maciej Pasternacki wrote an
w_link(`http://www.3ofcoins.net/2009/02/07/yaclml-in-pictures-part-i-html-generation/',
excellent introductory article) about YACLML where he also compares it with CL-WHO')
is a function-based HTML generation facility that you might want to take a look at.


!!! Continuation-based tools

Some neat features of Weblocks are built on continuations. But don't worry,
you will only need some high-level understanding of continuations to use
these features along with some rules of thumb.



! Widgets

!! Building a widget

Most widgets consist of two main parts:

  # a class definition using the ww_symbol(DEFWIDGET) macro.

  # a method for ww_symbol(RENDER-WIDGET-BODY) specialized
    on the widget's class.


!! Rendering protocol

Map over the currently active (by URI) widget tree:

{{{
  render-widget -> render-widget-body (widget-update-children?)
}}}


! Forms

Forms enable the user to communicate with a web application.

Usually the server side action boils down to selecting, modifying, creating or
deleting data sets (this is sometimes abbreviated as CRUD: Create/Read/Update/Delete)

Building  web forms is usually a cumbersome process. Elaborate but complicated
solutions have been devised`'w_footnote(for example PHP's Quickform extensions),
but so far we haven't found any of them to match the ease of use and flexibility
of Weblocks' declarative view DSL.


!! Introduction

The form mechanism consists of two parts, the ww_symbol(DATAFORM) widget and
the ww_symbol(FORM-VIEW) view type.

Forms are usually built by defining form views using the ww_symbol(DEFVIEW) macro
and instantiating a ww_symbol(DATAFORM) object with this view.


!! Simple example

Let's define a view for creating and editing bug reports.

Let the model be defined thus:

CODE_BEGIN lisp
(defclass bug-report ()
  ((id :type integer :initform (create-unique-id))
   (status :type (member :new :open :resolved) :initform :new)
   (summary :type string)
   (body :type string)))
CODE_END

This view should apply to users that are not developers: they may
enter a summary and body but that's it.

CODE_BEGIN lisp
(defview bug-report-form-view
    (:type form :inherit-from '(:scaffold bug-report)
     :caption "Enter a bug report")
  (id :hidep t)
  (status :hidep t))
CODE_END

The ww_symbol(SUMMARY) and ww_symbol(BODY) fields will default to
strings; every form field is presented as a text input and parsed as a
string by default.

Let's use this view to derive the view for developers:

CODE_BEGIN lisp
(defview bug-report-form-view/developer
    (:type form :inherit-from 'bug-report-form-view )
  (status :hidep nil))
CODE_END

The status field will automatically be displayed as a dropdown control
since the scaffold inspector has decided this upon the slot's type.

You can define scaffolding rules for your own types.  dnl TODO: document this somewhere.

As part of the validation process Weblocks will also check whether a
user input matches the slot's type regardless of whether you use
scaffolding or not.


But let's assume that we want custom labels for the dropdown:

CODE_BEGIN lisp
(defview bug-report-form-view/developer
    (:type form :inherit-from 'bug-report-form-view )
  (status :hidep nil
          :present-as (dropdown :choices '(("This report is totally new, don't trust it!" . :new)
                                           ("Yeah okay, we're working on it." . :open)
                                           ("We've solved that problem already..." . :resolved)))))
CODE_END





!! Quickforms

ww_symbol(Quickform)s are specialized ww_symbol(Dataform)s.

They provide a way to build forms based entirely on a view; they are handy
for operations where you don't have the user working on an actual model instance.

Let's dive right into it:

CODE_BEGIN lisp

CODE_END


! Views

!! Syntax of declarative view declaration

The macro ww_symbol(DEFVIEW) is a declarative DSL for defining views.

Syntax:

{{{
 (defview (NAME [:type TYPE] [:inherit-from INHERIT-FROM]
                [:satisfies SATISFIES] VIEW-KWARGS...)
   [FIELD-NAME
    | (FIELD-NAME [:type FIELD-TYPE] [:initform INITFORM]
		  [:present-as PRESENT-AS] [:parse-as PARSE-AS]
		  FIELD-KWARGS...)]...)
}}}

In the above form, these metasyntactic variables have the following values:

    NAME::
	When non-nil, an unevaluated unique symbol identifying the
	view to other parts of the system that require a view,
	resolving it using `find-view'.

    TYPE::
	An unevaluated designator for the class of the resulting
	view (determined by `view-class-name'), and half the
	designator for the class of this view's fields (determined by
	`view-field-class-name' applied to `view-default-field-type').
	Defaults to `data'.

    INHERIT-FROM::
	A designator for `view' slot `inherit-from'.  Forms
	like (:scaffold DATA-CLASS) will replace :scaffold with TYPE.
	See `find-view' for further transformation.

        Evaluated.

    SATISFIES::
	A designator for `form-view' slot `satisfies'.

        Evaluated.

    VIEW-KWARGS::
	Other arguments passed directly to `make-instance' for the
	resulting view, quoting subject to
	`view-argument-quoting-strategy'.

Argument semantics:

    FIELD-NAME::
	An unevaluated designator for `view-field' slot `slot-name'.

    FIELD-TYPE::
	A designator for the class of the field, in combination with
	TYPE, as explained above for TYPE.

    FIELD-KWARGS::
	Other arguments passed directly to `make-instance' for the
	resulting view field, quoting subject to
	`view-argument-quoting-strategy'.

        However, ww_symbol(FIELD-KWARGS) keywords present in
        ww_symbol(`*'CUSTOM-VIEW-FIELD-ARGUMENT-COMPILERS*)' are not included in the
        call to ww_symbol(MAKE-INSTANCE); see that variable for information on
        how those are transformed.

The built-in custom view fields are as follows:

    INITFORM::
	A form for `mixin-view-field' slot `initform' (which is
	really an initfunction).

    PRESENT-AS::
	A designator for `view-field' slot `presentation'.  The symbol
	or CAR is mapped to a class name through
	`presentation-class-name', and the CDR, a series of keyword
	arguments, is passed to `make-instance' on said class, subject
	to `view-argument-quoting-strategy'.

    PARSE-AS::
	A designator for `form-view-field' slot `parser'.  Otherwise
	similar to PRESENT-AS, but mapping class names using
	`parser-class-name'."


!! Configuring view fields at run-time

!! Customizing  scaffolding


!! Limitations


!!! Available presentations


!!! Available parsers


! Continuation-based tools

!! A high-level explanation of continuations



!! How Weblocks uses continuations

Only to replace widgets and remember how to restore the original state. XXX VERIFY


!! Continuation-based tools

!!! Widget replacements

!!! Modal dialogs

!! When to use ww_symbol(WITH-CALL/CC) and ww_symbol(LAMBDA/CC)


! Dependency handling

! HTML generation

At the moment only CL-WHO is supported out of the box, but YAML and others may
also be used.


!! CL-WHO

examples to point out pitfalls


!! Utilities

!!! WITH-HTML-FORM



! Working with continuations

!! Introduction
!! Widget continuations
!! Using the high-level interfaces


! Adapting Weblocks to your needs

!! Introduction, Hooks

Every GF is a hook: subclass, :before, :around, :after

!! Writing a presentation

!! Writing a form field parser

!! Writing a dispatcher

!! Integrating 3rd party Javascript

!! Deploying multiple Webapps



! Weblocks Internals

Not only useful for those wishing to hack the internals but also to gain
an understanding of Weblocks that aids in debugging hard problems.

!! Request handler

!! Dispatching mechanism

!!! Widget tree update mechanism

  The whole tree update protocol goes like this:

  1) HANDLE-NORMAL-REQUEST calls UPDATE-WIDGET-TREE, which walks the
  tree using WALK-WIDGET-TREE starting at ROOT-WIDGET and calling
  update-children at every node.

  2) The selector's UPDATE-CHILDREN method (valid for all selectors,
  i.e. widgets that process URI tokens) calls GET-WIDGET-FOR-TOKENS.

  3) if a widget corresponding to particular URI tokens is found,
  UPDATE-CHILDREN calls UPDATE-DEPENDENTS, so that the selector (or its
  subclass) may update its dependents list and do other housekeeping.
  The default implementation of UPDATE-DEPENDENTS just calls
  (SETF WIDGET-CHILDREN) to store the children under the :SELECTOR
  type.

  Usually the only thing you'll want to do if you are implementing your
  own kind of selector is to subclass selector and provide a
  GET-WIDGET-FOR-TOKENS method for it. See class ON-DEMAND-SELECTOR for
  an example."))


!!! Selectors

(defgeneric get-widget-for-tokens (selector uri-tokens)
  (:documentation "Given a list of URI tokens, map them to a widget. All
  selectors implement this method. There can be multiple strategies for
  mapping URI tokens to widgets: static maps, dynamically-generated
  widgets, dynamically-generated widgets with caching. Returns a widget
  or NIL if not found. Modifies URI-TOKENS.


!! Views

views are the second highest level mechanism (after forms) in the weblocks
system of forms, views, presentations & parsers that form the rendering
framework for structured data. views are defined using defview.

defview is a macro that in turn calls defview-anon. defview-anon is not visible
outside weblocks -- if you have to use it, call it with weblocks::defview-anon.
defview-anon actually makes the view, defview attaches a gensym'd name to it
and stores it in the global views hash.

so all views are global, and any changes made to one show up in all the others
(at least after a refresh of the browser).

!! Form pipeline


! Contributing to Weblocks

# checkout branch
# make changes
!! test changes (how?)
Run a specific test case: (run-test :test-case 'make-dialog-js-3 :suite 'composite-suite)

# add tests (where?)
# make patch
# discussion/review

See tutorial at http://trac.common-lisp.net/cl-weblocks/wiki/WeblocksDevelopment


! Hints

!! Basic SBCL setup
w_label(appA,Appendix A: Basic SBCL setup)

I recommend the following SBCL initialization file (on UNIX systems it is w_literal(~/.sbclrc)):


CODE_BEGIN lisp
; stale FASLs
(defmethod asdf:perform :around ((o asdf:load-op) (c asdf:cl-source-file))
    (handler-case (call-next-method o c)
      (#+sbcl sb-ext:invalid-fasl
       #-(or sbcl allegro lispworks cmu) error ()
       (asdf:perform (make-instance 'asdf:compile-op) c)
       (call-next-method))))using aclrepl (see also w_url(http://www.sbcl.org/manual/sb_002daclrepl.html))
CODE_END

rlwrap (w_url(http://freshmeat.net/projects/rlwrap/))
clbuild


!! Debugging Techniques

TRACE (beware builtin funs), BACKTRACE, DESCRIBE
If no errors show up (sometimes occurs e.g. when working with continuations!)
try *CATCH-ERRORS-P*


!! Deployment

detachtty
screen
tmux
remote swank


!! Store comparison
w_label(appC,Appendix C: Store comparison)

Different stores have different merits. Here's a short comparison.


!!! cl-prevalence

This library embodies the prevalence database strategy:
Everything is kept in main memory; all writes are logged
to disk, and the in-memory database is restored with the
aid of the log at initialization time.

!!!! Advantages

  * This means excellent speed
    and seamless integration with CL as query language.


!!!! Disadvantages

  * No transaction support for objects in memory.

  * Database size limited by size of virtual memory.

  * No load balancing capabilities (but you can run the
    database on a separate machine)

!!!! Bottom line

Prevalence is a great library to start with because you
can do carefree prototyping and also run production sites.

w_strong(Important note:) The original version of cl-prevalence has
some bugs that prevent is from working reliably when used with Weblocks.

It is recommended to use the fork at
w_url(`http://bitbucket.org/skypher/cl-prevalence/')
where this problem has been remedied.


!!! Elephant

Elephant is based on a key-value database model (like SQL servers)
It offers convenient CLOS integration and decent speed.

!!!! Advantages

  * Transactions affect in-memory objects.

  * Excellent support for schema updates: Elephant manages
    most issues on its own even across process boundaries.
    Special cases (slot migration/deletion) can be specified
    by the user by hooking into the MOP.

  * Queries are formulated completely in CL.

!!!! Negatives

  * Less speed than cl-prevalence especially with a high
    number of slot accesses.

  * Watch out when handling primitive types like arrays
    and conses, Elephant doesn't have its hooks in there.

  * BDB backend: load balancing not easily realized.

  * PostgreSQL backend: incomplete support for sorting
    values containing NIL.

!!!! Bottom line

Not as easy to set up as cl-prevalence, but a great library
to work with.


!!! CLSQL

The CLSQL store relies on the popular SQL ecosystem. This means
proven client-server management systems like PostgreSQL, hosts
of excellent tools and great interoperability.

On the negative side SQL has an impedance mismatch when matched
against object-oriented data structures.

You cannot use CL as a query language either, CLSQL only provides
a Lispy layer over SQL.


!! Weblocks compared to other frameworks

!!! At a glance

w_beg(table,r,c,c,c,c,c,c)
                                 || Weblocks    || UCW/AJAX         || Seaside || PLT Webserver || RubyOnRails || Django //
Language                         || Common Lisp || Common Lisp || Smalltalk || Scheme || Ruby || Python //
Supports REST                    || Yes         ||  ||  || Yes || Yes || Yes //
Supports multi-tier dispatch     || Yes         ||  ||  ||  || || //
AJAX support built-in            || Yes         || Yes ||  ||  || No || No //
Degrades gracefully without AJAX || Yes         || No || (N/A) || (N/A) || No || No //
Scaffolding/DRY                  || Dynamic     ||  ||  || No || Static || //
Support for non-SQL databases    || Yes         ||  ||  || Yes || No || //
Interactive debugging            || Yes         || Yes || Yes || Yes || No || No //
Bundling/compression built-in    || Yes         ||   ||  ||  || No || No //
Community                        || Tiny        || Tiny  ||  Small || Small || Medium || Medium //
Community support                || Yes         ||  ||  ||  || Yes || Yes //
Commercial support               || Yes         || Yes || Yes ||  || Yes || Yes //
License                          || LLGPL       ||  || || || ||  //
w_end(table)

!!! In-depth comparison

Weblocks

Django:		read basics at djangobook.com
	  	Django works at a level similar to hunchentoot. A series of urls is mapped to functions. Templates can be used to fill in html.
		Uses mvc.

Python:		Twisted?
		Google App Engine?

Rails:    	Uses mvc. Ruby has some nice language features. Framework is backwards, and forces you to repeat yourself many times. A guiding
		principle is to not repeat yourself (colloquially DRY) and in combination with a poor DSL it can be quite gibberishy.
                Strongly tied to SQL as data store.

Ruby:		Other?

Perl:		Mason?

PHP:		Cake?

Seaside


