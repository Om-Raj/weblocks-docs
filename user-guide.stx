title: Weblocks User Guide
author: Leslie P. Polzer
date: 27. May 2009
language: english

w_begdiv(metas)
dnl <link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="pygments-style.css"/>
<link rel="stylesheet" type="text/css" href="weblocks.css"/>
w_enddiv(metas)

dnl define(`ww_symbol',`w_literal(translit($1,`a-z',`A-Z'))')
define(`ww_symbol',`w_emph(translit($1,`A-Z',`a-z'))')

This is the user's guide to Weblocks.

http://teddyb.org/rlp/tiki-index.php?page!Learning+About+Weblocks

! Introduction

!! Getting Support

There is both excellent community and professional support available for Weblocks.

Community support is available via the Google group at
w_url(`http://groups.google.com/group/weblocks').

For commercial support and consulting contact Leslie P. Polzer
`<'w_link(`mailto:polzer@gnu.org',`w_literal(`polzer@gnu.org')')`>'.


!! Installation

!!! Setup your Common Lisp environment

You can skip this section if you already have a comfortable Common Lisp environment.


!!!! Common Lisp implementation

First you must choose a Common Lisp implementation.

Weblocks is designed and implemented to be portable and should run on the most popular
Common Lisp implementations. It is currently tested best on SBCL and Clozure CL, though.


!!!! Development environment setup

There are at least two fundamentally different development approaches for using
Common Lisp:

  # Editor-centric development: you access all Lisp functions from within your editor.

    Example: Emacs/Slime, Vim/Limp, Lispworks/IDE.
    
    Incremental development happens mainly on the S-Expression level. This means that you
    edit a SEXP and send it with the help of editor directly to your Lisp image, which
    evaluates it, thus affecting the current Lisp environment.

  # UNIX-style development: one tool for each job. The editor is not all that important
    here (as long as you're comfortable with it and it supports at least a basic level
    of paren highlighting.
    
    Example: Vim and your favorite terminal emulator. You start Vim in one window and
    your Lisp in another. Interaction happens by reloading your applications ASDF system
    and simple copy/paste of snippets.

We will try to be largely agnostic of the development approach in this manual which actually
means that we tend towards the second approach: Lisp calls are referred to by what you'd
type in your REPL, not by Emacs shortcut as it is often the case.

For a basic comfortable SBCL setup, see w_refer(appA,`Appendix A').
 

!!!! Installation

There is a comprehensive installation guide on the main web site:

  http://weblocks.viridian-project.de/installation


!! Setting up a project

Weblocks comes with a simple application template generator.

Start your Lisp and run

CODE_BEGIN lisp
(wop:make-app 'NAME "DIR")
CODE_END

This will initialize a barebones application called NAME in directory
DIR.

Another effective way to hack on a new application is copying
the code of an application from the w_literal(examples/) directory.


!! Components of Weblocks

!!! Widgets

Widgets are the main building blocks of Weblocks (hence the name).

At the heart of Weblocks is a tree`'w_footnote(An acyclic graph with exactly one
parent per node) of widgets that is manipulated by the clients requests. When a
client sends its first request to a Weblocks application then a new session is
started for it and a widget tree is associated with this session.

This initial widget tree is computed as defined by the application developer.
A special function (usually called ww_symbol(init-user-session)) is called by Weblocks
to initialize a new session. This function then proceeds to set up a
widget tree by adding children to the root of the widget tree
(accessible with the macro ww_symbol(root-widget)).

The initial content and structure of the widget tree may depend on arbitrary
factors; it is conceivable (although probably not very sensible) to generate
different widget trees depending on the time of day.

A client's request for a specific URI modifies the widget tree: widgets
called /dispatchers/ choose their one child based on the current request
URI.

There is a convenience function ww_symbol(MAKE-WIDGET) that creates widgets
from strings (anything that can be printed, in fact) and functions.


!!! Actions

Apart from session initialization the widget tree may be modified by /actions/.

Actions are plain functions that are stored in a session hash table the keys
of which are unique identifiers. This way they can be called by the browser.

When Javascript is available actions will be called via AJAX, otherwise
a normal request will be initiated.

It is often useful to set up closures as actions.

Example of typical action usage:

CODE_BEGIN lisp
(defwidget counter ()
  ((count :accessor count-of :initform 0)))

(defmethod render-widget-body ((widget my-widget) &rest args)
  (with-html
    (:p (esc (format nil "The counter is at ~D." (count-of widget))))
    (:p (render-link
         (lambda (&rest args)
          ;; closes over WIDGET.
          (incf (count-of widget)))
         "Count up!"))))
CODE_END


!!! Navigations and dispatchers

Dispatchers are widget that configure themselves and their children
(i.e. broadly speaking the widget tree) based on the URI of the request.

Navigations are dispatchers that maintain a simple one-to-one association between
an URI token`'w_footnote(each path component of an URI is a token; for example
in `"/foo/bar/quux"' there are three tokens foo, bar and quux.) and
a widget.

Note that each widget can also in turn be a navigation that consumes an
URI token, thereby building a many-to-many relationship between tokens
and widgets.

The function ww_symbol(MAKE-NAVIGATION) is a convenience frontend for building
navigations.

The first argument is a title for the navigation. The rest of the arguments
map tokens to widgets:

CODE_BEGIN lisp
(defun init-user-session (root)
  (setf root (make-navigation "Food Shop"
                              "Fruits" (make-fruit-navigation)
                              "Vegetables" (make-vegetables-navigation)
                              "Billing" (make-instance 'billing-widget :shop-type 'food))))
CODE_END

ww_symbol(MAKE-WIDGET) is applied to the widget argument so you can use strings
and function designators`'w_footnote(i.e. symbols naming a global function
and function objects themselves) instead of widgets in this context.


!!! Views

Views provide convenient ways to define how data object are to
be rendered.

Weblocks currently comes with three types of views: data views, table views
and form views.

Form views are especially useful because they let you build forms
in a declarative manner, error checking and reporting included. 

Views mainly consist of a rendering framework unique to the
view`'w_footnote(The table view for example knows how to render a HTML table.)
and a series of view fields.

View fields usually map to the slots of your data class but they are
flexible enough to be used in any other way. Associated with each view field
irregardless of the view type are things like a human-readable label and
information on how to render the field (presentation).

Form views include additional parameters like how to translate user
input to a proper model value (parser) and constraints on the data
(satisfies).


!! Stores

Weblocks offers a storage framework with several backends. At the
moment the supported backends are Elephant, cl-prevalence, CLSQL
and in-memory storage.

You are free to use your own storage mechanisms, however.

w_refer(appC,`Appendix C') offers a comparison of the different stores.


!!! Applications

One Lisp image may serve multiple web applications at once.

The target web application of a request can be determined based
on the hostname, the port or the URI for example.

You don't have to worry much about this if you only intend to
run a single application.


!!! HTML and Javascript generation facilities and utilies

Weblocks comes with CL-WHO and Parenscript, two powerful packages
that provide Lisp compilers for HTML and Javascript.

This means no more munging around with strings, which in turn
means

  * no more annoying mistakes like forgetting a semicolon
    or forgetting to close a tag

  * no need to remember infix precedence rules 

  * make full use of Lisps selective quoting facilities

Javascript may still be written as simple strings however.
This comes in handy sometimes when working with a larger example
copied from a Javascript library manual.

And you're free to use other facilities as you prefer.
For example YACLML`'w_footnote(`Maciej Pasternacki wrote an
w_link(`http://www.3ofcoins.net/2009/02/07/yaclml-in-pictures-part-i-html-generation/',
excellent introductory article) about YACLML where he also compares it with CL-WHO')
is a function-based HTML generation facility that you might want to take a look at.


!!! Continuation-based tools

Some neat features of Weblocks are built on continuations. But don't worry,
you will only need some high-level understanding of continuations to use
these features along with some rules of thumb.



! Widgets

!! Building a widget

Most widgets consist of two main parts:

  # a class definition using the ww_symbol(DEFWIDGET) macro.

  # a method for ww_symbol(RENDER-WIDGET-BODY) specialized
    on the widget's class.


!! Rendering protocol

Map over the currently active (by URI) widget tree:

{{{
  render-widget -> render-widget-body (widget-update-children?)
}}}


! Forms

Forms enable the user to communicate with a web application.

Usually the server side action boils down to selecting, modifying, creating or
deleting data sets (this is sometimes abbreviated as CRUD: Create/Read/Update/Delete)

Building  web forms is usually a cumbersome process. Elaborate but complicated
solutions have been devised`'w_footnote(for example PHP's Quickform extensions),
but so far we haven't found any of them to match the ease of use and flexibility
of Weblocks' declarative view DSL.


!! Introduction

The form mechanism consists of two parts, the ww_symbol(DATAFORM) widget and
the ww_symbol(FORM-VIEW) view type.

Forms are usually built by defining form views using the ww_symbol(DEFVIEW) macro
and instantiating a ww_symbol(DATAFORM) object with this view.


!! Simple example

Let's define a view for creating and editing bug reports.

Let the model be defined thus:

CODE_BEGIN lisp
(defclass bug-report ()
  ((id :type integer :initform (create-unique-id))
   (status :type (member :new :open :resolved) :initform :new)
   (summary :type string)
   (body :type string)))
CODE_END

This view should apply to users that are not developers: they may
enter a summary and body but that's it.

CODE_BEGIN lisp
(defview bug-report-form-view
    (:type form :inherit-from '(scaffold bug-report)
     :caption "Enter a bug report")
  (id :hidep t)
  (status :hidep t))
CODE_END

The ww_symbol(SUMMARY) and ww_symbol(BODY) fields will default to
strings; every form field is presented as a text input and parsed as a
string by default.

Let's use this view to derive the view for developers:

CODE_BEGIN lisp
(defview bug-report-form-view/developer
    (:type form :inherit-from 'bug-report-form-view )
  (status :hidep nil))
CODE_END

The status field will automatically be displayed as a dropdown control
since the scaffold inspector has decided this upon the slot's type.

You can define scaffolding rules for your own types.  dnl TODO: document this somewhere.

As part of the validation process Weblocks will also check whether a
user input matches the slot's type regardless of whether you use
scaffolding or not.


But let's assume that we want custom labels for the dropdown:

CODE_BEGIN lisp
(defview bug-report-form-view/developer
    (:type form :inherit-from 'bug-report-form-view )
  (status :hidep nil
          :present-as (dropdown :choices '(("This report is totally new, don't trust it!" . :new)
                                           ("Yeah okay, we're working on it." . :open)
                                           ("We've solved that problem already..." . :resolved)))))
CODE_END





!! Quickforms

ww_symbol(Quickform)s are specialized ww_symbol(Dataform)s.

They provide a way to build forms based entirely on a view; they are handy
for operations where you don't have the user working on an actual model instance.

Let's dive right into it:

CODE_BEGIN lisp

CODE_END


! Views

!! Syntax of declarative view declaration

The macro ww_symbol(DEFVIEW) is a declarative DSL for defining views.

Syntax:

{{{
 (defview (NAME [:type TYPE] [:inherit-from INHERIT-FROM]
                [:satisfies SATISFIES] VIEW-KWARGS...)
   [FIELD-NAME
    | (FIELD-NAME [:type FIELD-TYPE] [:initform INITFORM]
		  [:present-as PRESENT-AS] [:parse-as PARSE-AS]
		  FIELD-KWARGS...)]...)
}}}

In the above form, these metasyntactic variables have the following values:

    NAME::
	When non-nil, an unevaluated unique symbol identifying the
	view to other parts of the system that require a view,
	resolving it using `find-view'.

    TYPE::
	An unevaluated designator for the class of the resulting
	view (determined by `view-class-name'), and half the
	designator for the class of this view's fields (determined by
	`view-field-class-name' applied to `view-default-field-type').
	Defaults to `data'.

    INHERIT-FROM::
	A designator for `view' slot `inherit-from'.  Forms
	like (:scaffold DATA-CLASS) will replace :scaffold with TYPE.
	See `find-view' for further transformation.

        Evaluated.

    SATISFIES::
	A designator for `form-view' slot `satisfies'.

        Evaluated.

    VIEW-KWARGS::
	Other arguments passed directly to `make-instance' for the
	resulting view, quoting subject to
	`view-argument-quoting-strategy'.

Argument semantics:

    FIELD-NAME::
	An unevaluated designator for `view-field' slot `slot-name'.

    FIELD-TYPE::
	A designator for the class of the field, in combination with
	TYPE, as explained above for TYPE.

    FIELD-KWARGS::
	Other arguments passed directly to `make-instance' for the
	resulting view field, quoting subject to
	`view-argument-quoting-strategy'.

        However, ww_symbol(FIELD-KWARGS) keywords present in
        ww_symbol(`*'CUSTOM-VIEW-FIELD-ARGUMENT-COMPILERS*)' are not included in the
        call to ww_symbol(MAKE-INSTANCE); see that variable for information on
        how those are transformed.

The built-in custom view fields are as follows:

    INITFORM::
	A form for `mixin-view-field' slot `initform' (which is
	really an initfunction).

    PRESENT-AS::
	A designator for `view-field' slot `presentation'.  The symbol
	or CAR is mapped to a class name through
	`presentation-class-name', and the CDR, a series of keyword
	arguments, is passed to `make-instance' on said class, subject
	to `view-argument-quoting-strategy'.

    PARSE-AS::
	A designator for `form-view-field' slot `parser'.  Otherwise
	similar to PRESENT-AS, but mapping class names using
	`parser-class-name'."


!! Configuring view fields at run-time


!! Limitations


!!! Available presentations


!!! Available parsers


! Unsorted

!! Applications

!! HTML generation facilities and utilies

At the moment only CL-WHO is supported out of the box, but YAML and others may
also be used.


! Continuation-based tools

!! A high-level explanation of continuations



!! How Weblocks uses continuations

Only to replace widgets and remember how to restore the original state. XXX VERIFY


!! Continuation-based tools

!!! Widget replacements

!!! Modal dialogs

!! When to use ww_symbol(WITH-CALL/CC) and ww_symbol(LAMBDA/CC)


! Dynamic scaffolding

!! Customizing scaffolding


! Building widgets

Widgets are lisp classes (of metaclass widget) declared using the defwidget
macro. They are associated with a rendering function, [[ the generic function
''render-widget-body'' ]]  which is reponsible for creating the html associated
with the widget. Using metaclass hooks, whenever the widget object in lisp is
changed, an updated html representation is sent out at the next http request
(or ajax request).  [[ The framework will take this html and write it into a
div with an id unique to the widget. Mostly one doesn't need to worry about it,
but see [render-widget-body] for times when you do. ]]

! Common Errors

One of the most common problems is missing updates because of a missing widget. 
The widget can be missing in many ways: one is creating a widget *inside* a rendering function.
Example: 


In this case, the widget b will get rendered once, but all updates will be lost!
The solution is to make the widget ''a'' derive from composite [[ ''(defwidget a
(composite))'' ]] and then make that last r-w-b call into ''(call-next-method)''
or ''(r-w-b X)'' where ''X'' is the widget of type ''b'' contained within ''a''.

TODO look at newsgroup for more examples. 

! Dependency handling

! HTML generation

!! CL-WHO

examples to point out pitfalls


!! HTML abstractions

!!! WITH-HTML-FORM


! Views forms presentations parsers 

!!! Rules and guidelines for using defview.

!! Introduction

views are the second highest level mechanism (after forms) in the weblocks
system of forms, views, presentations & parsers that form the rendering
framework for structured data. views are defined using defview.

defview is a macro that in turn calls defview-anon. defview-anon is not visible
outside weblocks -- if you have to use it, call it with weblocks::defview-anon.
defview-anon actually makes the view, defview attaches a gensym'd name to it
and stores it in the global views hash.

so all views are global, and any changes made to one show up in all the others (at least after a refresh of the browser).


dnl ! CSS generation
dnl 
dnl FIXME: implement first ;)


! Working with continuations

!! Introduction
!! Widget continuations
!! Using the high-level interfaces


! Adapting Weblocks to your needs

!! Introduction, Hooks

Every GF is a hook: subclass, :before, :around, :after

!! Writing a presentation

!! Writing a form field parser

!! Writing a dispatcher

!! Integrating 3rd party Javascript


! Webapps



! In-depth Weblocks

Not only useful for those wishing to hack the internals but also to gain
an understanding of Weblocks that aids in debugging hard problems.

!! Request handler

!! Dispatching mechanism

!!! Widget tree update mechanism

  The whole tree update protocol goes like this:

  1) HANDLE-NORMAL-REQUEST calls UPDATE-WIDGET-TREE, which walks the
  tree using WALK-WIDGET-TREE starting at ROOT-WIDGET and calling
  update-children at every node.

  2) The selector's UPDATE-CHILDREN method (valid for all selectors,
  i.e. widgets that process URI tokens) calls GET-WIDGET-FOR-TOKENS.

  3) if a widget corresponding to particular URI tokens is found,
  UPDATE-CHILDREN calls UPDATE-DEPENDENTS, so that the selector (or its
  subclass) may update its dependents list and do other housekeeping.
  The default implementation of UPDATE-DEPENDENTS just calls
  (SETF WIDGET-CHILDREN) to store the children under the :SELECTOR
  type.

  Usually the only thing you'll want to do if you are implementing your
  own kind of selector is to subclass selector and provide a
  GET-WIDGET-FOR-TOKENS method for it. See class ON-DEMAND-SELECTOR for
  an example."))


!!! Selectors

(defgeneric get-widget-for-tokens (selector uri-tokens)
  (:documentation "Given a list of URI tokens, map them to a widget. All
  selectors implement this method. There can be multiple strategies for
  mapping URI tokens to widgets: static maps, dynamically-generated
  widgets, dynamically-generated widgets with caching. Returns a widget
  or NIL if not found. Modifies URI-TOKENS.


!! Form pipeline


! Debugging Techniques

TRACE (beware builtin funs), BACKTRACE, DESCRIBE
If no errors show up (sometimes occurs e.g. when working with continuations!)
try *CATCH-ERRORS-P*


! Contributing

# checkout branch
# make changes
!! test changes (how?)
Run a specific test case: (run-test :test-case 'make-dialog-js-3 :suite 'composite-suite)

# add tests (where?)
# make patch
# discussion/review

http://lighthouseapp.com/help/setting-up-subversion-integration


! Working on Weblocks

!! Mercurial Bitbucket 

See tutorial at http://trac.common-lisp.net/cl-weblocks/wiki/WeblocksDevelopment

Weblocks as a project maintains its source in mercurial. Hosting is provided by
bitbucket.org -- accounts are free (and you get one private repo for free).
Space limits are generous, 150MB or so. There is an irc channel
(#bitbucket.org) with helpful admins but you should not need it. SSH keys are
supported, so once that is setup starting is as easy as creating a repository
using the web interface, then (nunb is the user, repo-name is the repo you just
created):

hg clone ssh://hg@bitbucket.org/nunb/repo-name
.. edit files in your new local repo (dir repo-name) .. now commit your changes:
hg commit 
hg push
.. push them out to the parent, and your changes are now safely stored at bitbucket ..


!! Contributing changes 

This section paraphrased from jespern at #bitbucket.org -- thanks!

Use web interface and create a fork, say weblocks-mine. Clone it locally, and
use it everyday.  Make your changes to it, and push as necessary. Now you can
send a pull request to the weblocks
maintainers to pull a cool feature you've added.

Generally, you can put your stuff in the subdir contrib. This keeps it out of
everyone's way and yet makes it available. But then divergences from weblocks
will be silently missed.  If your code change is core and useful enough,
consider adding it to the main src and possibly adding to weblocks.asd

Note, your fork will *not* keep getting updated with the main line changes, you
have to keep it in sync yourself.

That's pretty easy to do, you just pull changes from the weblocks mainline when
necessary, you do not need to log onto the web interface either.

For example, in the local shell in your forked directory root, just do 'hg pull -u https://bitbucket.org/skypher/weblocks-stable/'

Now, in the repo dir, the command 'hg pull' will by default pull from the place
you cloned it -- which is your private fork. If you only work on this local
machine, you don't really need to update from that fork, but rather from the
mainline.

To make the command shorter create an alias for the mainline: 

<jespern> you can edit .hg/hgrc in your forked repo, and in the [paths]
          section, just add something like 'orig = https://...', then you can
          do 'hg pull -u orig'   

Also: read up on patch queues if you only want to keep mainline up to date.
However, there has been some discussion that weblocks won't use patch queues
any more?

<jespern> if you just want to contribute and keep the mainline up to date, you
	  may want to consider working on a patch queue instead of a fork


!! Frequent newbie hg issue

(This section paraphrased from conversation with Leslie Polzer -- thanks!).

Often, if you are making changes, and try to do 'hg pull -u' (or hg pull
followed by hg update) your changes clash with others. The error message is:

Upstream changes TODO exact message?

The best way of dealing with it is to commit your local changes.. option a) below.

Handling the error message (follow these steps after you get the error message)

 1. If there are no uncommitted working directory changes,
    just issue ''hg fetch''.

 2. If there are yet uncommitted working directory changes
    either

    a) Commit them and go to 1.

    b) Park them somewhere else with ''hg diff'', then do ''hg fetch''
       and re-apply the diff with ''patch''.

    c) Use the Shelve extension to make option b) more convenient:

       ''hg shelve && hg fetch && hg unshelve''


!! Lighthouse Trac

Originally weblocks was on trac, and there was a wiki there. Because lighthouse
offers better issue tracking, weblocks now has an open issues/bugtracker on
lighthouse.

A new wiki is needed?


!! Tutorials, sites, blogs



! Hints

!! Basic SBCL setup
w_label(appA,Appendix A: Basic SBCL setup)

I recommend the following SBCL initialization file (on UNIX systems it is w_literal(~/.sbclrc)):


CODE_BEGIN lisp
; stale FASLs
(defmethod asdf:perform :around ((o asdf:load-op) (c asdf:cl-source-file))
    (handler-case (call-next-method o c)
      (#+sbcl sb-ext:invalid-fasl
       #-(or sbcl allegro lispworks cmu) error ()
       (asdf:perform (make-instance 'asdf:compile-op) c)
       (call-next-method))))using aclrepl (see also w_url(http://www.sbcl.org/manual/sb_002daclrepl.html))
CODE_END

rlwrap (w_url(http://freshmeat.net/projects/rlwrap/))
clbuild


!! Deployment

detachtty
screen
tmux
remote swank


!! Store comparison
w_label(appC,Appendix C: Store comparison)

Different stores have different merits. Here's a short comparison.


!!! cl-prevalence

This library embodies the prevalence database strategy:
Everything is kept in main memory; all writes are logged
to disk, and the in-memory database is restored with the
aid of the log at initialization time.

!!!! Advantages

  * This means excellent speed
    and seamless integration with CL as query language.


!!!! Disadvantages

  * No transaction support for objects in memory.

  * Database size limited by size of virtual memory.

  * No load balancing capabilities (but you can run the
    database on a separate machine)

!!!! Bottom line

Prevalence is a great library to start with because you
can do carefree prototyping and also run production sites.

w_strong(Important note:) The original version of cl-prevalence has
some bugs that prevent is from working reliably when used with Weblocks.

It is recommended to use the fork at
w_url(`http://bitbucket.org/skypher/cl-prevalence/')
where this problem has been remedied.


!!! Elephant

Elephant is based on a key-value database model (like SQL servers)
It offers convenient CLOS integration and decent speed.

!!!! Advantages

  * Transactions affect in-memory objects.

  * Excellent support for schema updates: Elephant manages
    most issues on its own even across process boundaries.
    Special cases (slot migration/deletion) can be specified
    by the user by hooking into the MOP.

  * Queries are formulated completely in CL.

!!!! Negatives

  * Less speed than cl-prevalence especially with a high
    number of slot accesses.

  * Watch out when handling primitive types like arrays
    and conses, Elephant doesn't have its hooks in there.

  * BDB backend: load balancing not easily realized.

  * PostgreSQL backend: incomplete support for sorting
    values containing NIL.

!!!! Bottom line

Not as easy to set up as cl-prevalence, but a great library
to work with.


!!! CLSQL

The CLSQL store relies on the popular SQL ecosystem. This means
proven client-server management systems like PostgreSQL, hosts
of excellent tools and great interoperability.

On the negative side SQL has an impedance mismatch when matched
against object-oriented data structures.

You cannot use CL as a query language either, CLSQL only provides
a Lispy layer over SQL.


!! Weblocks compared to other frameworks

!!! At a glance

w_beg(table,r,c,c,c,c,c,c)
                                 || Weblocks    || UCW/AJAX         || Seaside || PLT Webserver || RubyOnRails || Django //
Language                         || Common Lisp || Common Lisp || Smalltalk || Scheme || Ruby || Python //
Supports REST                    || Yes         ||  ||  || Yes || Yes || Yes //
Supports multi-tier dispatch     || Yes         ||  ||  ||  || || //
AJAX support built-in            || Yes         || Yes ||  ||  || No || No //
Degrades gracefully without AJAX || Yes         || No || (N/A) || (N/A) || No || No //
Scaffolding/DRY                  || Dynamic     ||  ||  || No || Static || //
Support for non-SQL databases    || Yes         ||  ||  || Yes || No || //
Interactive debugging            || Yes         || Yes || Yes || Yes || No || No //
Bundling/compression built-in    || Yes         ||   ||  ||  || No || No //
Community                        || Tiny        || Tiny  ||  Small || Small || Medium || Medium //
Community support                || Yes         ||  ||  ||  || Yes || Yes //
Commercial support               || Yes         || Yes || Yes ||  || Yes || Yes //
License                          || LLGPL       ||  || || || ||  //
w_end(table)

!!! In-depth comparison

Weblocks

Django:		read basics at djangobook.com
	  	Django works at a level similar to hunchentoot. A series of urls is mapped to functions. Templates can be used to fill in html.
		Uses mvc.

Python:		Twisted?
		Google App Engine?

Rails:    	Uses mvc. Ruby has some nice language features. Framework is backwards, and forces you to repeat yourself many times. A guiding
		principle is to not repeat yourself (colloquially DRY) and in combination with a poor DSL it can be quite gibberishy.
                Strongly tied to SQL as data store.

Ruby:		Other?

Perl:		Mason?

PHP:		Cake?

Seaside



! Assorted stuff

!! Views are singletons

this makes it hard to do per-view things. two examples of these per-view things
you may want to do are:

1. translate labels or use specific labels (perhaps per-session, per-user if users have different language preferences)
2. use different submit buttons, or fields-suffix and -prefix functions (see the definition of form-view in formview.lisp)

a partial solution is to make the basic view you need with defview, and then
create an on-the-fly specific view using defview-anon and using the initializer
:inherit-from '<your-specific-view-name> (there should be only a single quote
char).

in this case however, you will often have to respecify many things about the view.
TODO: it appears fields are copied without problem in view inheritance, but *not* other things such as type
of view, satisfiers etc. (see functions get-object-view-fields and compute-view-field-info-list in utils.lisp)

the solution above is partial because at the moment views are not garbage collected, but this
is being looked into.

to this view you can adjust labels, fields functions as needed, and it will not
affect any other view. to use the view you must specifically tell the dataform
to use it, or use make-quickform -- which lets you specify the view as the
first parameter.

!! View gotchas

Inside a view, specifying 

does not work -- function calls don't appear to be acceptable (in this example, ''#!"abc"'' expands to ''cl-i18n:translate("abc")'')

!! Fields inside views

views are made up of fields. at rendering time the framework needs both the
data which this field represents, and the way it is to be presented and parsed,
which is encoded in the view (in the form of present-as and parse-as, or the
defaults for that view type).

in addition, a context to the widget that rendering is happening in is maintained,
thus most functions in the rendering hierarchy will have at least the args
view, object & widget.

fields are converted into field-info objects at rendering-time, which basically just
involves encapsulating the actual object into a struct of type field-info.

!! Views inside views

there is a special type of field definition in a view though: one that represents another view to be
mixed in. in the following defview, this mixin-field is defined for location-details.

(defview enter-details-of-person 
  (:type form :inherit-from '(:scaffold co-employee) 
	      :caption "Enter Personal Information" )
  (location-details :type mixin :view 'location-form-view)
  (contact-details  :type mixin :view 'contact-form-view)
  (firstname :label "firstname")
  (lastname  :label "lastname")
  (sin   :hidep t)
  (notes :label "Notes")
  (company :label "Employer" ))

imagine that the data object this view is defined for consists of several pieces of simple information,
as well as one sub-object of class location-details, one of contact-details, and one of company. 

in fact the class of the object we want to view could be defined as follows:

(defclass mba-applicant (person)
  ((firstname        :accessor get-firstname        :initarg :firstname		:initform "")
   (lastname         :accessor get-lastname         :initarg :lastname		:initform "" :type (or string null))
   (company          :accessor get-company          :initarg :company		:initform (make-instance 'company :company-name "Facade"))
   (contact-details  :accessor get-location-details :initarg :location-details	:initform (make-instance 'contact  :cellphone "908" :email "foo@bar.com"))
   (location-details :accessor get-location-details :initarg :location-details	:initform (make-instance 'location :city "Vatican" :location "Hades"))
   (sin              :accessor get-sin              :initarg :sin		:initform "wants to be a manager all hoity-toity with an MBA")
   (notes            :accessor get-notes            :initarg :notes		:initform "made up a 3 billion dollar company to put on his resume")))

firstname et al. would normally be defined inside person. now the :initforms of each field of the class tell us the kind
of object that is stored there. we can see that some fields are simple (strings, numbers and the like) and some complex
(structs, objects). the former are represented by normal fields in views, and the latter by mixin fields.

in addition, a :type specifier would also tell us what is permissible to store, as in lastname above. if specified, this is checked in validations.lisp when a form is being deserialized.

!! Getting the value of field data

!! Other ways of getting this value

